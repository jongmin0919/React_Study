<!--9월 13일 공부 : 리액트의 특징들 (P27-P37)-->

1. 리액트는 JSX(JSeXtension)문법을 사용하는데
   HTML과 매우 비슷하면서도 자바의 JSP와 비슷한 문법 형태를 보인다고 합니다.
2. 이벤트를 통해 명시적으로 데이터를 갱신하는 방법으로 단방향 바인딩 방식(Flux 개념)을 채택함으로서
   오버 스펙을 낮추는 방식을 채택.
3. 기존의 html, css, js의 렌더링 과정 중에서 빈번하게 발생 되는 리플로와 리페인팅의 과정을 해소하고자
   가상돔이라는 개념을 도입 함으로서 가상돔에서의 렌더링 과정이 모두 끝난 후
   최종적으로 해당 화면을 최적으로 갱신 할수 있습니다.
4. 어떻게(how)에 초점을 맞춘 명령형 프로그래밍은 코드의 장문화를 불러오는대에 반해
   리액트는 무엇(what)에 초점을 맞춘 선언형 프로그래밍, 특히 JSX의 활용을 통해 비선언형 부분을
   캡슐화 하는대에 용이합니다.
5. 리액트의 가장 큰 강점은 컴포넌트 개념을 도입했다는 점입니다. 페이지의 영역 전체를 구조화하여
   그 페이지 자체를 불러왔던 이전 방식 대신 특정 페이지에 필요한 구역 부분들을 모아 그때그때
   페이지를 갱신한다는 것입니다.

<!--------------------------------------★ 1번 내용------------------------------------------->

const App = () => {

  <!-- 1. 기본적인 메인 화면 선언 방법 -->

const greeting = "Hello world!";

  <!-- 2. greeting 변수에 출력할 문구를 삽입 후 -->

return <div>{greeting}</div>;

  <!-- 3. html문법의 div 태그 안에 해당 변수를 브락켓으로 감싼 후 반환 해준다. -->

};

export default App;

<!-- 4. 해당 App 오브젝트를 기본값으로 출력. -->

<!-- -------------------------------------★ 4번 내용----------------------------------------- -->

const App2 = () => {
const arr = [1, 2, 3, 4, 5];

  <!-- 1. 배열 선언 -->

return (

  <!-- 2. 반환을 할건데 -->

    <ul>

      {arr.map((elem) => (
        <!-- 3. 그 안에 arr 배열을 map메서드를 호출하여 elem 콜백 함수를 지정한 후 -->
        <li>{elem}</li>
        <!-- 4. li태그 안의 해당 elem들을 하나하나, 즉 배열의 1부터 5까지 순환하여 생성하도록 함. -->
      ))}
    </ul>

);
};

<!-- -------------------------------------★ 5번 내용----------------------------------------- -->

const Title = () => {
return <h1>Hello World!</h1>;

  <!-- 1. Title 컴포넌트에는 h1 태그 안의 특정 문구를 출력하는 부분을 작성. -->

};
const Button = () => {
return <button>This is a Button</button>;

  <!-- 2. Button 컴포넌트에는 button 태그 안의 문구와 버튼을 출력하는 부분을 작성. -->

};

const App3 = () => {

  <!-- 3. 갱신을 할 페이지에 -->

return (
<div>
<Title />
<Button />
<!-- 4. div태그 안에 Title과 Button 컴포넌트를 불러와주기만 하면 끝. -->
</div>
);
};
