<!--9월 13일 공부 : 리액트의 특징들 (P27-P37) // 깃허브 리포지토리 연결 완료-->

1. 리액트는 JSX(JSeXtension)문법을 사용하는데
   HTML과 매우 비슷하면서도 자바의 JSP와 비슷한 문법 형태를 보인다고 합니다.

<!--------------------------------------★ 1번 내용------------------------------------------->

```
const App = () => {

  <!-- 1. 기본적인 메인 화면 선언 방법 -->

const greeting = "Hello world!";

  <!-- 2. greeting 변수에 출력할 문구를 삽입 후 -->

return <div>{greeting}</div>;

  <!-- 3. html문법의 div 태그 안에 해당 변수를 브락켓으로 감싼 후 반환 해준다. -->

};

export default App;
```

<!-- 4. 해당 App 오브젝트를 기본값으로 출력. -->

2. 이벤트를 통해 명시적으로 데이터를 갱신하는 방법으로 단방향 바인딩 방식(Flux 개념)을 채택함으로서
   오버 스펙을 낮추는 방식을 채택.
3. 기존의 html, css, js의 렌더링 과정 중에서 빈번하게 발생 되는 리플로와 리페인팅의 과정을 해소하고자
   가상돔이라는 개념을 도입 함으로서 가상돔에서의 렌더링 과정이 모두 끝난 후
   최종적으로 해당 화면을 최적으로 갱신 할수 있습니다.
4. 어떻게(how)에 초점을 맞춘 명령형 프로그래밍은 코드의 장문화를 불러오는대에 반해
   리액트는 무엇(what)에 초점을 맞춘 선언형 프로그래밍, 특히 JSX의 활용을 통해 비선언형 부분을
   캡슐화 하는대에 용이합니다.

<!-- -------------------------------------★ 4번 내용----------------------------------------- -->

const App2 = () => {
const arr = [1, 2, 3, 4, 5];

  <!-- 1. 배열 선언 -->

return (

  <!-- 2. 반환을 할건데 -->

    <ul>

      {arr.map((elem) => (
        <!-- 3. 그 안에 arr 배열을 map메서드를 호출하여 elem 콜백 함수를 지정한 후 -->
        <li>{elem}</li>
        <!-- 4. li태그 안의 해당 elem들을 하나하나, 즉 배열의 1부터 5까지 순환하여 생성하도록 함. -->
      ))}
    </ul>

);
};

5. 리액트의 가장 큰 강점은 컴포넌트 개념을 도입했다는 점입니다. 페이지의 영역 전체를 구조화하여
   그 페이지 자체를 불러왔던 이전 방식 대신 특정 페이지에 필요한 구역 부분들을 모아 그때그때
   페이지를 갱신한다는 것입니다.

<!-- -------------------------------------★ 5번 내용----------------------------------------- -->

const Title = () => {
return <h1>Hello World!</h1>;

  <!-- 1. Title 컴포넌트에는 h1 태그 안의 특정 문구를 출력하는 부분을 작성. -->

};
const Button = () => {
return <button>This is a Button</button>;

  <!-- 2. Button 컴포넌트에는 button 태그 안의 문구와 버튼을 출력하는 부분을 작성. -->

};

const App3 = () => {

  <!-- 3. 갱신을 할 페이지에 -->

return (

<div>
<Title />
<Button />
<!-- 4. div태그 안에 Title과 Button 컴포넌트를 불러와주기만 하면 끝. -->
</div>
);
};


<!--9월 16일 공부 : 1-1 Create-react-app 생성 방법 (P46-P47) -->

1. 우선 리액트 프로젝트를 설치하기 위해서는 리액트 도구를 설치해야 하며, 다음의 명령을 터미널에 입력하게 됩니다.
- npm install -g create-react-app -> Node.js 패키지 관리자인 npm을 사용하여 전역(Global)으로 앱을 생성하겠다는 뜻.
- npx create-react-app projectname --template=typescript -> Node.js 패키지 관리 도구인 npx를 사용해
  특정 이름의 앱을 만드는데 프로젝트의 템플릿을 타입스크립트로 지정하겠다는 뜻.
  (npm은 프로젝트 간의 종속성 및 모듈 업데이트의 일관성으로 인해 권장되지 않으며 최근에는 프로젝트 마다의 영향을 배제하면서 최신 리액트 버전 유지가 가능한 npx 명령 사용이 권장 된다고 합니다.)
- 추가로 타입스크립트 적용 없이 npx create-react-app projectname만 입력하여 프로젝트를 생성 하였다면
  npm install --save-dev typescript @types/node @types/react @types/react-dom 명령어 입력을 통해
  개발 의존성을 추가한 후 노드, 리액트, 리액트 돔 타입 정의 및 해당 기능들에 접근시 필요한 타입스크립트 타입 정보를 제공합니다.
  물론 이렇게 기존 리액트 프로젝트에 추가로 타입스크립트를 적용하게 될경우 js 확장자를 tsx 확장자로 일일이 바꾸어 주어야 하거나, src 폴더 안에 custom.d.ts를 추가하여 추가로 자바스크립트 파일을 타입스크립트 파일로 변경해야 하고, 마찬가지로 reportWebvitals.ts 내부 구조를 수정해야 하는 번거로움이 있기에 프로젝트 생성시에는 타입스크립트를 적용 하는 명령어를 적용하는 것이 편합니다.
2. 이후 해당 리액트 프로젝트가 생성 되었다면 npx create-react-app 명령 입력을 통해 버전 확인이 가능합니다. 
3. 버전까지 확인 후 npx create-react-app appname을 통해 리액트의 프로젝트를 생성합니다.
4. 프로젝트가 생성 되었다면 cd appname을 입력하여 해당 파일로 이동한 후 npm start를 통해 리액트를 실행합니다.
(물론 npx를 통해 앱을 생성 하였다면 yarn start를 입력하여 앱 실행도 가능하여 선택적으로 실행이 가능합니다.)

<!--9월 16일 공부 : 1-2 Create-react-app 폴더 구조 (P48-P51) -->

1. create-react-app을 통해 프로젝트를 생성하면 폴더의 구조는 크게 package, README.md를 제외한 public과 src 폴더로 나누어 집니다.
2, public 폴더에는 기본 웹프레임이 되는 index.html을 포함한 HTML 파일과 favicon 등의 정적인 파일들이 담겨있고, src 폴더에는 실제 리액트로 프로그래밍을 하는 자바스크립트 파일들이 담겨있습니다.
3. index.html의 코드는 기본적으로 <div id = "root"></div> 로 되어있으며 이 부분은 실제 프로그래밍된 리액트 애플리케이션이 표시됩니다. 이 애플리케이션은 src 폴더의 index.js를 통해 연결됩니다.

<!-- -------------------------------------★ 3번 내용----------------------------------------- -->

import App from './App';
<!-- App컴포넌트를 임포트 -->

const root = ReactDOM.createRoot(document.getElementById('root'));
<!-- root 변수에 리액트 돔을 이용하여 idex.html의 root id를 가진 div태그를 선택한 후 루트 실제 루트 요소를 생성하여 담습니다. -->
root.render(
<!-- 해당 루트를 렌더링 할건데 -->
  <React.StrictMode>
  <!-- 엄격한 모드로 렌더링을 할것이고 -->
    <App />
  <!-- App 컴포넌트를 루트 컴포넌트로 지정합니다. 이 App/ 파일 안에는 하위 컴포넌트들이 자리하게 됩니다. -->
  </React.StrictMode>
);

4. 앞서 리액트 앱을 실행하기 위해 입력한 명령어인 npm start는 package.json 파일 내부의 scripts 오브젝트에 설정됩니다. 
이 파일의 해당 부분에는 start 뿐만 아니라 사용자가 원하는 명령어를 지정하는 것도 가능하며 이를 제외한 어플리케이션 배포를 위한 build, 배포 전 테스트를 위한 test 및 도구의 내부 설정 및 스크립트를 프로젝트에 완전히 노출 시키는 eject 명령어도 확인 및 임의 지정 할 수 있습니다. 그러나 왠만해서는 건들지 않는 것이 좋습니다.

<!-- -------------------------------------★ 4번 내용----------------------------------------- -->

"Scripts" : {
  "start" : "react-scripts start", 
  <!-- 리액트 스크립트 실행을 할 때의 명령어 -->
  "build" : "react-scripts build",
  <!-- 리액트 스크립트를 빌드 할 때의 명령어 -->
  "test" : "react-scripts test",
  <!-- 리액트 스크립트를 테스트 할 때의 명령어 -->
  "eject" : "react-scripts eject"
  <!-- 리액트 스크립트의 내부 설정 및 구조를 드러내고자 할 때의 명령어 -->
};

<!--9월 16일 공부 : 1-3 나의 첫 리액트 프로젝트  (P58-P) -->

1. 리액트에서 스타일링(CSS)를 사용하기 위해서는 우선 public 파일 안에 CSS파일을 생성한 후 index.html <link /> 태그로 CSS 파일을 추가하는 것으로 해당 스타일링을 리액트 앱에 적용 할 수 있습니다.

<!-- -------------------------------------★ 1번 내용----------------------------------------- -->

<link rel = "stylesheet" href = %PUBLIC_URL%/custom.css />
<!-- html에 CSS 파일 연결시 link 태그를 사용하며 href 경로에 %PUBLIC_URL% 경로를 입력하여 도구가 경로를 자동으로 해석 할 수 있게 할수 있습니다.(편리하게 지정 가능)-->

2. 링크가 html 파일 내부에 추가 되었다면 실제 컴포넌트 구조는 App.tsx에서 변경해야 합니다.

<!-- -------------------------------------★ 2번 내용----------------------------------------- -->

<!-- CSS 파일 구조 -->
.App-header{
  background-color : green !important;
}

<!-- App.js 파일 구조 -->
function App(){
  return (
    <header className = "App-header">
     ㆍㆍㆍ
    <header>
  );
};


3. 이렇게 각각의 컴포넌트에 CSS 파일을 분리하여 지정하는 것도 가능하지만 이렇게 될 경우 클래스명이 중복되어 의도치 않는 스타일이 적용 됩니다. 이를 해결하기 위해 CSS-in-JS 방법론을 적용하여 컴포넌트에 직접 스타일을 지정 함으로 쉽게 적용 및 관리가 가능해집니다. 
- 해당 CSS-in-JS 속성이 적용 된 프로젝트를 생성하기 위해 다음 명령어를 입력합니다.
  ( npm create-react-app my-app-css-in-js --template=typescript) 
- 해당 프로젝트로 이동 후 이모션을 추가합니다. 이 이모션을 관리하여 컴포넌트에 적용되는 CSS 코드를 대체하게 됩니다.
  ( npm install --save @emotion/react @emotion/styled )
- App.tsx 파일을 열은 후 해당 코드를 임포트 합니다. 이후에는 App.tsx 파일 내부에 있던 App.css를 임포트 할 필요가 없어집니다. 
  ( import styled from '@emotion/styled'; )
- 다시 App.tsx 파일 내부에 템플릿 리터럴(백틱)을 활용하여 새로운 컴포넌트를 생성해줍니다.

  const Container = Styled.div`
    text-align : center;
  `;

- 이후 해당 스타일을 App.css 파일 안에 똑같이 추가해 줍니다.
  
  .App {
    text-align : center;
  }

- 다시 돌아와 App.tsx 파일에서 스타일을 적용 시켜줄 부분에 container tag를 생성해 줍니다.

function App(){
  return (
    <Container>
    </Container>
  );
};

- 이 작업들을 진행할 경우 스타일이 정상적으로 적용되며 다른 스타일도 적용하게 될 경우 위의 절차대로 이모션을 추가하여 스타일을 적용해주면 됩니다.
