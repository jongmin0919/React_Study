<!--9월 13일 공부 : 리액트의 특징들 (P27-P37) // 깃허브 리포지토리 연결 완료-->

1. 리액트는 JSX(JSeXtension)문법을 사용하는데
   HTML과 매우 비슷하면서도 자바의 JSP와 비슷한 문법 형태를 보인다고 합니다.

<!--------------------------------------★ 1번 내용------------------------------------------->

const App = () => {

  <!-- 1. 기본적인 메인 화면 선언 방법 -->

const greeting = "Hello world!";

  <!-- 2. greeting 변수에 출력할 문구를 삽입 후 -->

return <div>{greeting}</div>;

  <!-- 3. html문법의 div 태그 안에 해당 변수를 브락켓으로 감싼 후 반환 해준다. -->

};

export default App;

<!-- 4. 해당 App 오브젝트를 기본값으로 출력. -->

2. 이벤트를 통해 명시적으로 데이터를 갱신하는 방법으로 단방향 바인딩 방식(Flux 개념)을 채택함으로서
   오버 스펙을 낮추는 방식을 채택.
3. 기존의 html, css, js의 렌더링 과정 중에서 빈번하게 발생 되는 리플로와 리페인팅의 과정을 해소하고자
   가상돔이라는 개념을 도입 함으로서 가상돔에서의 렌더링 과정이 모두 끝난 후
   최종적으로 해당 화면을 최적으로 갱신 할수 있습니다.
4. 어떻게(how)에 초점을 맞춘 명령형 프로그래밍은 코드의 장문화를 불러오는대에 반해
   리액트는 무엇(what)에 초점을 맞춘 선언형 프로그래밍, 특히 JSX의 활용을 통해 비선언형 부분을
   캡슐화 하는대에 용이합니다.

<!-- -------------------------------------★ 4번 내용----------------------------------------- -->

const App2 = () => {
const arr = [1, 2, 3, 4, 5];

  <!-- 1. 배열 선언 -->

return (

  <!-- 2. 반환을 할건데 -->

    <ul>

      {arr.map((elem) => (
        <!-- 3. 그 안에 arr 배열을 map메서드를 호출하여 elem 콜백 함수를 지정한 후 -->
        <li>{elem}</li>
        <!-- 4. li태그 안의 해당 elem들을 하나하나, 즉 배열의 1부터 5까지 순환하여 생성하도록 함. -->
      ))}
    </ul>

);
};

5. 리액트의 가장 큰 강점은 컴포넌트 개념을 도입했다는 점입니다. 페이지의 영역 전체를 구조화하여
   그 페이지 자체를 불러왔던 이전 방식 대신 특정 페이지에 필요한 구역 부분들을 모아 그때그때
   페이지를 갱신한다는 것입니다.

<!-- -------------------------------------★ 5번 내용----------------------------------------- -->

const Title = () => {
return <h1>Hello World!</h1>;

  <!-- 1. Title 컴포넌트에는 h1 태그 안의 특정 문구를 출력하는 부분을 작성. -->

};
const Button = () => {
return <button>This is a Button</button>;

  <!-- 2. Button 컴포넌트에는 button 태그 안의 문구와 버튼을 출력하는 부분을 작성. -->

};

const App3 = () => {

  <!-- 3. 갱신을 할 페이지에 -->

return (

<div>
<Title />
<Button />
<!-- 4. div태그 안에 Title과 Button 컴포넌트를 불러와주기만 하면 끝. -->
</div>
);
};


<!--9월 16일 공부 : 1-1 Create-react-app 생성 방법 (P46-P47) -->

1. 우선 리액트 프로젝트를 설치하기 위해서는 리액트 도구를 설치해야 하며, 다음의 명령을 터미널에 입력하게 됩니다.
- npm install -g create-react-app -> Node.js 패키지 관리자인 npm을 사용하여 전역(Global)으로 앱을 생성하겠다는 뜻.
- npx create-react-app projectname --template=typescript -> Node.js 패키지 관리 도구인 npx를 사용해
(npm은 프로젝트 간의 종속성 및 모듈 업데이트의 일관성으로 인해 권장되지 않으며 최근에는 프로젝트 마다의 영향을 배제하면서 최신 리액트 버전 유지가 가능한 npx 명령 사용이 권장 된다고 합니다.)
특정 이름의 앱을 만드는데 프로젝트의 템플릿을 타입스크립트로 지정하겠다는 뜻.
2. 이후 해당 리액트 프로젝트가 생성 되었다면 npx create-react-app 명령 입력을 통해 버전 확인이 가능합니다. 
3. 버전까지 확인 후 npx create-react-app appname을 통해 리액트의 프로젝트를 생성합니다.
4. 프로젝트가 생성 되었다면 cd appname을 입력하여 해당 파일로 이동한 후 npm start를 통해 리액트를 실행합니다.
(물론 npx를 통해 앱을 생성 하였다면 yarn start를 입력하여 앱 실행도 가능하여 선택적으로 실행이 가능합니다.)

<!--9월 16일 공부 : 1-2 Create-react-app 폴더 구조 (P48-P51) -->

1. create-react-app을 통해 프로젝트를 생성하면 폴더의 구조는 크게 package, README.md를 제외한 public과 src 폴더로 나누어 집니다.
2, public 폴더에는 기본 웹프레임이 되는 index.html을 포함한 HTML 파일과 favicon 등의 정적인 파일들이 담겨있고, src 폴더에는 실제 리액트로 프로그래밍을 하는 자바스크립트 파일들이 담겨있습니다.
3. index.html의 코드는 기본적으로 <div id = "root"></div> 로 되어있으며 이 부분은 실제 프로그래밍된 리액트 애플리케이션이 표시됩니다. 이 애플리케이션은 src 폴더의 index.js를 통해 연결됩니다.

<!-- -------------------------------------★ 3번 내용----------------------------------------- -->

import App from './App';
<!-- App컴포넌트를 임포트 -->

const root = ReactDOM.createRoot(document.getElementById('root'));
<!-- root 변수에 리액트 돔을 이용하여 idex.html의 root id를 가진 div태그를 선택한 후 루트 실제 루트 요소를 생성하여 담습니다. -->
root.render(
<!-- 해당 루트를 렌더링 할건데 -->
  <React.StrictMode>
  <!-- 엄격한 모드로 렌더링을 할것이고 -->
    <App />
  <!-- App 컴포넌트를 루트 컴포넌트로 지정합니다. 이 App/ 파일 안에는 하위 컴포넌트들이 자리하게 됩니다. -->
  </React.StrictMode>
);

4. 앞서 리액트 앱을 실행하기 위해 입력한 명령어인 npm start는 package.json 파일 내부의 scripts 오브젝트에 설정됩니다. 
이 파일의 해당 부분에는 start 뿐만 아니라 사용자가 원하는 명령어를 지정하는 것도 가능하며 이를 제외한 어플리케이션 배포를 위한 build, 배포 전 테스트를 위한 test 및 도구의 내부 설정 및 스크립트를 프로젝트에 완전히 노출 시키는 eject 명령어도 확인 및 임의 지정 할 수 있습니다. 그러나 왠만해서는 건들지 않는 것이 좋습니다.

<!-- -------------------------------------★ 4번 내용----------------------------------------- -->

"Scripts" : {
  "start" : "react-scripts start",
  "build" : "react-scripts build",
  "test" : "react-scripts test",
  "eject" : "react-scripts eject"
};